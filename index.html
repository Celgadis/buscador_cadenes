<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .card{
      display: flex;
      flex-direction: column;
    }
    .coincidencia{
      display: flex;
      width: 100%;
      gap:30px
    }
    .muestra{
      height: 20px;
      width: 20px;
      border: 2px solid black;
      display: flex;
    }
  </style>
</head>
<body>
  <h3>Lista de archivos scss a revisar:</h3>
  <input type="file" id="fileInput" multiple />  
  <div class="resultado"></div>
  <div class="molde">
    <div class="card">
      <div class="coincidencia"><span class="muestra"></span><span class="valor"></span><span class="contador"></span></div>
      <div class="contenoedor-coincidencias">
          <ul class="coincidencias">
          </ul>
      </div>
    </div>

  </div>
</body>
</html>


<script>
  //expresiones regulares para separar rbg, variables, hexadecimales y el resto
  const listaRegex = [
    /rgb[^)]+[)]/,
    /\$[^; ]+/,
    /#[^;^ ^)^,]+/,
    /.{3,}/
  ];

  const palabrasClave = [
    {
      palabra: "color:",
      contador: 0,
      resultados: {}
    },
    {
      palabra: "border:",
      contador: 0,
      resultados: {}
    }];
  // const palabrasClave = ['color', 'border', 'fallo']; // Cambia esto segÃºn tus necesidades
    const listaResultados={};

  document.getElementById('fileInput').addEventListener('change', async (event) => {
    const archivos = Array.from(event.target.files);

    for (const archivo of archivos) {
      await procesarArchivo(archivo);
    }
    await descargarResultados();
    await mostrarResultados();
  });

  // FunciÃ³n que lee un archivo y busca las palabras clave lÃ­nea por lÃ­nea
  async function procesarArchivo(archivo) {
    const contenido = await leerArchivoComoTexto(archivo);
    const lineas = contenido.split('\n');

    console.log(`ðŸ“„ Procesando archivo: ${archivo.name}`);

    for (let i = 0; i < lineas.length; i++) {
      const linea = lineas[i];
      for (const clave of palabrasClave) {
        let palabra = clave.palabra;
        if (linea.toLowerCase().includes(palabra.toLowerCase())) {
          let resultado = `[${archivo.name}] LÃ­nea ${i + 1}: ${linea}`;
          //console.log(resultado);
          clave.contador++;
          let valor = linea.split(":");
          valor = valor[1].split("\r");
          valor = valor[0].trim();
          let coincidencia = null;
          let regexIndex=0
          //filtrado a traves de las regex
          for (const regex of listaRegex) {
            coincidencia = valor.match(regex)
            if (coincidencia) {
              coincidencia = coincidencia[0]
              if(regexIndex==0){//si es un color rgb se convierte a hex
                coincidencia=reemplazarRgbPorHexRgb(coincidencia);
                coincidencia=coincidencia.match(listaRegex[2])[0]
              }
              //console.log("coincidencia:", coincidencia)
              break;
            }
            regexIndex++
          }
          if(!coincidencia){
            break;
          }
          //preparamos la clave de orden con valores hsl para poder ver colores similares juntos
          let regexHex=/^#[0-9A-Fa-f]{3,6}$/;
          console.log("linia",linea)
          console.log("coincidencia",coincidencia)
          let hsl=coincidencia.match(regexHex)?hexToHSL(coincidencia):null

          let existe=listaResultados.hasOwnProperty(coincidencia);
          //si no se guardo esta coincidencia se crea, si no solo se aumenta el contador y se guarda la informacion de posicion
          if (!existe) {
            listaResultados[coincidencia] =   {
              valor: coincidencia,
              contador: 1,
              coincidencias:[],
              tipo:regexIndex,
              hsl:hsl
            }
            listaResultados[coincidencia].coincidencias.push({
                linea:resultado,
                archivo:archivo.name,
                pos: i,
                valor:linea,
                tipo:regexIndex,
                coincidenica:coincidencia
              });
          } else {
            listaResultados[coincidencia].contador++;
            listaResultados[coincidencia].coincidencias.push({
                linea:resultado,
                archivo:archivo.name,
                pos: i,
                valor:linea,
                tipo:regexIndex,
                coincidenica:coincidencia
              });
          }


        }
      }
    }
  }

  // FunciÃ³n para leer archivo como texto usando FileReader y promesa
  function leerArchivoComoTexto(archivo) {
    return new Promise((resolve, reject) => {
      const lector = new FileReader();

      lector.onload = (e) => resolve(e.target.result);
      lector.onerror = (e) => reject(e);

      lector.readAsText(archivo);
    });
  }


  async function descargarResultados() {

    // 1. Convertimos el array en un string
    const contenido = JSON.stringify(listaResultados)

    // 2. Creamos un blob con tipo texto
    const blob = new Blob([contenido], { type: 'text/plain' });

    // 3. Creamos un URL para el blob
    const url = URL.createObjectURL(blob);

    // 4. Creamos un <a> y simulamos un clic
    const enlace = document.createElement('a');
    enlace.href = url;
    enlace.download = 'resultados.json';
    document.body.appendChild(enlace);
    enlace.click();

    // 5. Limpiamos
    document.body.removeChild(enlace);
    URL.revokeObjectURL(url);
  }

  function reemplazarRgbPorHexRgb(texto) {
    return texto.replace(/rgba?\(\s*(\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\s*\)/g,
      (_, r, g, b, a) => {
        const hex =
          "#" +
          [r, g, b]
            .map((x) => parseInt(x).toString(16).padStart(2, "0"))
            .join("");

        return a !== undefined ? `rgba(${hex}, ${a})` : `rgb(${hex})`;
      });
  }

  async function mostrarResultados(){
    const contenedor=document.querySelector(".resultado");
    const lista=ordenar(listaResultados);
    for(const coincidencia of Object.values(lista)){
      const card=document.querySelector(".molde .card").cloneNode(true);
      card.querySelector(".valor").innerText=coincidencia.valor;
      let veces=coincidencia.contador==1?"vez":"veces";
      card.querySelector(".contador").innerText=`encontrado ${coincidencia.contador} ${veces}`;
      card.querySelector(".muestra").style.backgroundColor=coincidencia.valor
      console.log(coincidencia);
      for(const linea of coincidencia.coincidencias){
        const nodo=document.createElement("li");
        nodo.innerText=linea.linea
        card.querySelector(".coincidencias").appendChild(nodo);
      }
      contenedor.appendChild(card);
    }
  }

  /*function ordenar(original){
    const clavesColores = Object.keys(original);
    /*const clavesOrdenadas = Object.keys(original).sort();

    // Paso 2: Crear un nuevo objeto con las claves ordenadas
    const objetoOrdenado = {};

    for (const clave of clavesOrdenadas) {
      objetoOrdenado[clave] = original[clave];
    }
   // Ordenar por tono (Hue)
    const clavesOrdenadas = clavesColores.sort((a.orden, b.orden) => {
      const hslA = hexToHSL(a);
      console.log(a)
      console.log(b)
      const hslB = hexToHSL(b);
      return hslA.orden.h - hslB.orden.h;
    });

    // Paso 2: Crear un nuevo objeto con las claves ordenadas
    const objetoOrdenado = {};

    for (const clave of clavesOrdenadas) {
      objetoOrdenado[clave] = original[clave];
    }

    return objetoOrdenado;
  }*/

  function ordenar(original){
    // Paso 1: Obtener claves y ordenarlas
    const clavesOrdenadas = Object.keys(original).sort((a, b) => {
      const itemA = original[a];
      const itemB = original[b];

      const hslA = itemA.hsl;
      const hslB = itemB.hsl;

      const tieneHslA = hslA && typeof hslA.h === 'number';
      const tieneHslB = hslB && typeof hslB.h === 'number';

      // Priorizar los que tienen HSL
      if (tieneHslA && !tieneHslB) return -1;
      if (!tieneHslA && tieneHslB) return 1;

      // Ambos tienen HSL â†’ ordenar por h, s, l
      if (tieneHslA && tieneHslB) {
        if (hslA.h !== hslB.h) return hslA.h - hslB.h;
        if (hslA.s !== hslB.s) return hslA.s - hslB.s;
        return hslA.l - hslB.l;
      }

      // Ninguno tiene HSL â†’ ordenar alfabÃ©ticamente
      return a.localeCompare(b);
    });

    // Paso 2: Reconstruir objeto ordenado
    const objetoOrdenado = {};
    for (const clave of clavesOrdenadas) {
      objetoOrdenado[clave] = original[clave];
    }
    return objetoOrdenado;
  }


// FunciÃ³n para convertir HEX a HSL
function hexToHSL(hex) {
  // Quitar el # si lo tiene
  hex = hex.replace(/^#/, '');
  if (hex.length === 3) {
    hex = hex.split('').map(c => c + c).join('');
  }
  const r = parseInt(hex.slice(0, 2), 16) / 255;
  const g = parseInt(hex.slice(2, 4), 16) / 255;
  const b = parseInt(hex.slice(4, 6), 16) / 255;

  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h, s, l = (max + min) / 2;

  if (max === min) {
    h = s = 0; // gris
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r: h = ((g - b) / d + (g < b ? 6 : 0)); break;
      case g: h = ((b - r) / d + 2); break;
      case b: h = ((r - g) / d + 4); break;
    }
    h /= 6;
  }
  return { h: h * 360, s, l };
}
</script>